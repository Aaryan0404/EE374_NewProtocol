/// <reference path="../types/zen-observable.d.ts" />
import BaseObservable from "zen-observable";
declare const $observers: unique symbol;
export interface SubscriptionObserver<T> {
    closed: boolean;
    next(value: T): void;
    error(errorValue: any): void;
    complete(): void;
}
export interface Subscription {
    closed: boolean;
    unsubscribe(): void;
}
export interface Observer<T> {
    start?(subscription: Subscription): any;
    next?(value: T): void;
    error?(errorValue: any): void;
    complete?(): void;
}
export declare type Subscriber<T> = (observer: SubscriptionObserver<T>) => void | (() => void) | Subscription;
export interface ObservableLike<T> {
    subscribe?: Subscriber<T>;
    [Symbol.observable](): ObservableT<T> | ObservableLike<T>;
}
export declare class ObservableT<T> {
    constructor(subscriber: Subscriber<T>);
    subscribe(observer: Observer<T>): Subscription;
    subscribe(onNext: (value: T) => void, onError?: (error: any) => void, onComplete?: () => void): Subscription;
    [Symbol.observable](): ObservableT<T>;
    forEach(callback: (value: T) => void): Promise<void>;
    map<R>(callback: (value: T) => R): ObservableT<R>;
    filter(callback: (value: T) => boolean): ObservableT<T>;
    reduce(callback: (previousValue: T, currentValue: T) => T, initialValue?: T): ObservableT<T>;
    reduce<R>(callback: (previousValue: R, currentValue: T) => R, initialValue?: R): ObservableT<R>;
    flatMap<R>(callback: (value: T) => ObservableLike<R>): ObservableT<R>;
    concat<R>(...observable: Array<ObservableT<R>>): ObservableT<R>;
    static from<R>(observable: ObservableT<R> | ObservableLike<R> | ArrayLike<R>): ObservableT<R>;
    static of<R>(...items: R[]): ObservableT<R>;
}
export declare const Observable: typeof BaseObservable;
export declare type Observable<T> = ObservableT<T>;
/**
 * Observable subject. Implements the Observable interface, but also exposes
 * the `next()`, `error()`, `complete()` methods to initiate observable
 * updates "from the outside".
 *
 * Use `Observable.from(subject)` to derive an observable that proxies all
 * values, errors and the completion raised on this subject, but does not
 * expose the `next()`, `error()`, `complete()` methods.
 */
export declare class Subject<T> extends BaseObservable<T> implements ObservableLike<T> {
    private [$observers];
    constructor();
    complete(): void;
    error(error: any): void;
    next(value: T): void;
}
export {};
